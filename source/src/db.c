/*
 * WARNING: automatically generated by ort-c-source 0.8.14.
 * DO NOT EDIT!
 */
#define _GNU_SOURCE
#define _DEFAULT_SOURCE
#include <sys/queue.h>

#include <assert.h>
/*
 * Required for b64_ntop().
 */
#include <ctype.h>
#include <netinet/in.h>
#include <resolv.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdint.h> /* int64_t */
#include <stdlib.h>
#include <string.h>
#include <time.h> /* _XOPEN_SOURCE and gmtime_r()*/
#include <unistd.h>

#include <sqlbox.h>
#include <kcgi.h>
#include <kcgijson.h>

#include "db.h"

/*
 * File imported from gensalt.c.
 */
/*	$Id$ */
/*
 * Copyright (c) 2017 Kristaps Dzonsons <kristaps@bsd.lv>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * Use standard (but unsafe) Linux tools for salting.
 * Not secure.
 */

static const char *
_gensalt(void)
{
	size_t		  i;
	static char 	  salt[] = "$1$........";
	const char *const seedchars =
		"./0123456789ABCDEFGHIJKLMNOPQRST"
		"UVWXYZabcdefghijklmnopqrstuvwxyz";

	/* According to crypt(3), salt is at most 8 bytes. */

	for (i = 0; i < 8; i++)
		salt[i + 3] = seedchars[random() % 64];

	return salt;
}
/*
 * All SQL statements we'll later define in "stmts".
 */
enum	stmt {
	STMT_ELECTIONOFFICIAL_BY_UNIQUE_id,
	STMT_ELECTIONOFFICIAL_BY_UNIQUE_username,
	STMT_ELECTIONOFFICIAL_BY_SEARCH_0,
	STMT_VOTER_BY_UNIQUE_id,
	STMT_VOTER_BY_UNIQUE_idinfo,
	STMT_VOTER_BY_SEARCH_0,
	STMT_VOTER_BY_SEARCH_1,
	STMT_VOTER_BY_SEARCH_2,
	STMT_VOTER_INSERT,
	STMT_VOTER_UPDATE_0,
	STMT_VOTER_UPDATE_1,
	STMT_ELECTIONOFFICIALSESSION_BY_UNIQUE_id,
	STMT_ELECTIONOFFICIALSESSION_BY_SEARCH_0,
	STMT_ELECTIONOFFICIALSESSION_BY_SEARCH_1,
	STMT_ELECTIONOFFICIALSESSION_INSERT,
	STMT_ELECTIONOFFICIALSESSION_DELETE_0,
	STMT_VOTERUPDATESESSION_BY_UNIQUE_id,
	STMT_VOTERUPDATESESSION_BY_SEARCH_0,
	STMT_VOTERUPDATESESSION_BY_SEARCH_1,
	STMT_VOTERUPDATESESSION_INSERT,
	STMT_VOTERUPDATESESSION_DELETE_0,
	STMT__MAX
};

/*
 * Definition of our opaque "ort", which contains role information.
 */
struct	ort {
	/* Hidden database connection */
	struct sqlbox *db;
};

/*
 * Table columns.
 * The macro accepts a table name because we use AS statements a lot.
 * This is because tables can appear multiple times in a single query and 
 * need aliasing.
 */
#define DB_SCHEMA_ELECTIONOFFICIAL(_x) \
	#_x ".id" "," \
	#_x ".username" "," \
	#_x ".hash"
#define DB_SCHEMA_VOTER(_x) \
	#_x ".id" "," \
	#_x ".lastname" "," \
	#_x ".givennames" "," \
	#_x ".resaddress" "," \
	#_x ".mailaddress" "," \
	#_x ".registeredparty" "," \
	#_x ".birthdate" "," \
	#_x ".idinfo" "," \
	#_x ".status" "," \
	#_x ".initialregtime" "," \
	#_x ".lastupdatetime" "," \
	#_x ".confidential"
#define DB_SCHEMA_ELECTIONOFFICIALSESSION(_x) \
	#_x ".id" "," \
	#_x ".officialid" "," \
	#_x ".token" "," \
	#_x ".ctime"
#define DB_SCHEMA_VOTERUPDATESESSION(_x) \
	#_x ".id" "," \
	#_x ".voterid" "," \
	#_x ".token" "," \
	#_x ".ctime"

/*
 * Our full set of SQL statements.
 * We define these beforehand because that's how sqlbox(3) handles 
 * statement generation.
 * Notice the "AS" part: this allows for multiple inner joins without 
 * ambiguity.
 */
static	const char *const stmts[STMT__MAX] = {
	/* STMT_ELECTIONOFFICIAL_BY_UNIQUE_id */
	"SELECT " DB_SCHEMA_ELECTIONOFFICIAL(electionofficial) " FROM electionofficial WHERE electionofficial.id = ?",
	/* STMT_ELECTIONOFFICIAL_BY_UNIQUE_username */
	"SELECT " DB_SCHEMA_ELECTIONOFFICIAL(electionofficial) " FROM electionofficial WHERE electionofficial.username = ?",
	/* STMT_ELECTIONOFFICIAL_BY_SEARCH_0 */
	"SELECT " DB_SCHEMA_ELECTIONOFFICIAL(electionofficial) " FROM electionofficial "
		"WHERE electionofficial.username = ?",
	/* STMT_VOTER_BY_UNIQUE_id */
	"SELECT " DB_SCHEMA_VOTER(voter) " FROM voter WHERE voter.id = ?",
	/* STMT_VOTER_BY_UNIQUE_idinfo */
	"SELECT " DB_SCHEMA_VOTER(voter) " FROM voter WHERE voter.idinfo = ?",
	/* STMT_VOTER_BY_SEARCH_0 */
	"SELECT " DB_SCHEMA_VOTER(voter) " FROM voter "
		"WHERE voter.lastname LIKE ? AND voter.givennames LIKE ? AND voter.birthdate = ? AND voter.confidential = ?",
	/* STMT_VOTER_BY_SEARCH_1 */
	"SELECT " DB_SCHEMA_VOTER(voter) " FROM voter "
		"WHERE voter.lastname LIKE ? AND voter.givennames LIKE ? AND voter.resaddress LIKE ? AND voter.mailaddress LIKE ? AND voter.birthdate = ? AND voter.idinfo = ? AND voter.confidential = ?",
	/* STMT_VOTER_BY_SEARCH_2 */
	"SELECT " DB_SCHEMA_VOTER(voter) " FROM voter "
		"WHERE voter.lastname LIKE ? AND voter.givennames LIKE ? AND voter.resaddress LIKE ? AND voter.mailaddress LIKE ? AND voter.birthdate > ? AND voter.birthdate < ?",
	/* STMT_VOTER_INSERT */
	"INSERT INTO voter (lastname,givennames,resaddress,mailaddress,registeredparty,"
		" birthdate,idinfo,status,initialregtime,lastupdatetime,confidential) "
		"VALUES (?,?,?,?,?,?,?,?,?,?,?)",
	/* STMT_VOTER_UPDATE_0 */
	"UPDATE voter SET lastname = ?,givennames = ?,resaddress = ?,mailaddress = ?,registeredparty = ?,birthdate = ?,idinfo = ?,status = ?,lastupdatetime = ?,confidential = ? WHERE id = ?",
	/* STMT_VOTER_UPDATE_1 */
	"UPDATE voter SET status = ?,lastupdatetime = ? WHERE id = ?",
	/* STMT_ELECTIONOFFICIALSESSION_BY_UNIQUE_id */
	"SELECT " DB_SCHEMA_ELECTIONOFFICIALSESSION(electionofficialsession) "," 
		DB_SCHEMA_ELECTIONOFFICIAL(_b) " FROM electionofficialsession "
		"INNER JOIN electionofficial AS _b ON _b.id=electionofficialsession.officialid "
		"WHERE electionofficialsession.id = ?",
	/* STMT_ELECTIONOFFICIALSESSION_BY_SEARCH_0 */
	"SELECT " DB_SCHEMA_ELECTIONOFFICIALSESSION(electionofficialsession) "," 
		DB_SCHEMA_ELECTIONOFFICIAL(_b) " FROM electionofficialsession "
		"INNER JOIN electionofficial AS _b ON _b.id=electionofficialsession.officialid "
		"WHERE electionofficialsession.id = ? AND electionofficialsession.token = ?",
	/* STMT_ELECTIONOFFICIALSESSION_BY_SEARCH_1 */
	"SELECT " DB_SCHEMA_ELECTIONOFFICIALSESSION(electionofficialsession) "," 
		DB_SCHEMA_ELECTIONOFFICIAL(_b) " FROM electionofficialsession "
		"INNER JOIN electionofficial AS _b ON _b.id=electionofficialsession.officialid "
		"WHERE electionofficialsession.ctime < ?",
	/* STMT_ELECTIONOFFICIALSESSION_INSERT */
	"INSERT INTO electionofficialsession (officialid,token,ctime) VALUES (?,"
		" ?,?)",
	/* STMT_ELECTIONOFFICIALSESSION_DELETE_0 */
	"DELETE FROM electionofficialsession WHERE id = ? AND token = ?",
	/* STMT_VOTERUPDATESESSION_BY_UNIQUE_id */
	"SELECT " DB_SCHEMA_VOTERUPDATESESSION(voterupdatesession) "," DB_SCHEMA_VOTER(_a) " FROM voterupdatesession "
		"INNER JOIN voter AS _a ON _a.id=voterupdatesession.voterid "
		"WHERE voterupdatesession.id = ?",
	/* STMT_VOTERUPDATESESSION_BY_SEARCH_0 */
	"SELECT " DB_SCHEMA_VOTERUPDATESESSION(voterupdatesession) "," DB_SCHEMA_VOTER(_a) " FROM voterupdatesession "
		"INNER JOIN voter AS _a ON _a.id=voterupdatesession.voterid "
		"WHERE voterupdatesession.id = ? AND voterupdatesession.token = ?",
	/* STMT_VOTERUPDATESESSION_BY_SEARCH_1 */
	"SELECT " DB_SCHEMA_VOTERUPDATESESSION(voterupdatesession) "," DB_SCHEMA_VOTER(_a) " FROM voterupdatesession "
		"INNER JOIN voter AS _a ON _a.id=voterupdatesession.voterid "
		"WHERE voterupdatesession.ctime < ?",
	/* STMT_VOTERUPDATESESSION_INSERT */
	"INSERT INTO voterupdatesession (voterid,token,ctime) VALUES (?,?,?)",
	/* STMT_VOTERUPDATESESSION_DELETE_0 */
	"DELETE FROM voterupdatesession WHERE id = ? AND token = ?",
};

const struct kvalid valid_keys[VALID__MAX] = {
	{ valid_electionofficial_id, "electionofficial-id" },
	{ valid_electionofficial_username, "electionofficial-username" },
	{ valid_electionofficial_hash, "electionofficial-hash" },
	{ valid_voter_id, "voter-id" },
	{ valid_voter_lastname, "voter-lastname" },
	{ valid_voter_givennames, "voter-givennames" },
	{ valid_voter_resaddress, "voter-resaddress" },
	{ valid_voter_mailaddress, "voter-mailaddress" },
	{ valid_voter_registeredparty, "voter-registeredparty" },
	{ valid_voter_birthdate, "voter-birthdate" },
	{ valid_voter_idinfo, "voter-idinfo" },
	{ valid_voter_status, "voter-status" },
	{ valid_voter_initialregtime, "voter-initialregtime" },
	{ valid_voter_lastupdatetime, "voter-lastupdatetime" },
	{ valid_voter_confidential, "voter-confidential" },
	{ valid_electionofficialsession_id, "electionofficialsession-id" },
	{ valid_electionofficialsession_officialid, "electionofficialsession-officialid" },
	{ valid_electionofficialsession_token, "electionofficialsession-token" },
	{ valid_electionofficialsession_ctime, "electionofficialsession-ctime" },
	{ valid_voterupdatesession_id, "voterupdatesession-id" },
	{ valid_voterupdatesession_voterid, "voterupdatesession-voterid" },
	{ valid_voterupdatesession_token, "voterupdatesession-token" },
	{ valid_voterupdatesession_ctime, "voterupdatesession-ctime" },
};

/*
 * Finally, all of the functions we'll use.
 * All of the non-static functions are documented in the associated 
 * header file.
 */

void
db_trans_open(struct ort *ctx, size_t id, int mode)
{
	struct sqlbox *db = ctx->db;
	int c;

	if (mode < 0)
		c = sqlbox_trans_exclusive(db, 0, id);
	else if (mode > 0)
		c = sqlbox_trans_immediate(db, 0, id);
	else
		c = sqlbox_trans_deferred(db, 0, id);
	if (!c)
		exit(EXIT_FAILURE);
}

void
db_trans_rollback(struct ort *ctx, size_t id)
{
	struct sqlbox *db = ctx->db;

	if (!sqlbox_trans_rollback(db, 0, id))
		exit(EXIT_FAILURE);
}

void
db_trans_commit(struct ort *ctx, size_t id)
{
	struct sqlbox *db = ctx->db;

	if (!sqlbox_trans_commit(db, 0, id))
		exit(EXIT_FAILURE);
}

void
db_logging_data(struct ort *ort, const void *arg, size_t sz)
{

	if (!sqlbox_msg_set_dat(ort->db, arg, sz))
		exit(EXIT_FAILURE);
}

struct ort *
db_open(const char *file)
{

	return db_open_logging(file, NULL, NULL, NULL);
}

struct ort *
db_open_logging(const char *file,
	void (*log)(const char *, void *),
	void (*log_short)(const char *, ...), void *log_arg)
{
	size_t i;
	struct ort *ctx = NULL;
	struct sqlbox_cfg cfg;
	struct sqlbox *db = NULL;
	struct sqlbox_pstmt pstmts[STMT__MAX];
	struct sqlbox_src srcs[1] = {
		{ .fname = (char *)file,
		  .mode = SQLBOX_SRC_RW }
	};

	memset(&cfg, 0, sizeof(struct sqlbox_cfg));
	cfg.msg.func = log;
	cfg.msg.func_short = log_short;
	cfg.msg.dat = log_arg;
	cfg.srcs.srcs = srcs;
	cfg.srcs.srcsz = 1;
	cfg.stmts.stmts = pstmts;
	cfg.stmts.stmtsz = STMT__MAX;

	for (i = 0; i < STMT__MAX; i++)
		pstmts[i].stmt = (char *)stmts[i];

	ctx = malloc(sizeof(struct ort));
	if (ctx == NULL)
		goto err;

	if ((db = sqlbox_alloc(&cfg)) == NULL)
		goto err;
	ctx->db = db;

	/*
	 * Now actually open the database.
	 * If this succeeds, then we're good to go.
	 */

	if (sqlbox_open_async(db, 0))
		return ctx;
err:
	sqlbox_free(db);
	free(ctx);
	return NULL;
}

void
db_close(struct ort *p)
{
	if (p == NULL)
		return;
	sqlbox_free(p->db);
	free(p);
}

/*
 * Fill in a electionofficial from an open statement "stmt".
 * This starts grabbing results from "pos", which may be NULL to start 
 * from zero.
 * This follows DB_SCHEMA_ELECTIONOFFICIAL's order for columns.
 */
static void
db_electionofficial_fill(struct ort *ctx, struct electionofficial *p, const struct sqlbox_parmset *set, size_t *pos)
{
	size_t i = 0;

	if (pos == NULL)
		pos = &i;
	memset(p, 0, sizeof(*p));
	if (sqlbox_parm_int(&set->ps[(*pos)++], &p->id) == -1)
		exit(EXIT_FAILURE);
	if (sqlbox_parm_string_alloc
	    (&set->ps[(*pos)++], &p->username, NULL) == -1)
		exit(EXIT_FAILURE);
	if (sqlbox_parm_string_alloc
	    (&set->ps[(*pos)++], &p->hash, NULL) == -1)
		exit(EXIT_FAILURE);
}

static void
db_electionofficial_fill_r(struct ort *ctx, struct electionofficial *p,
	const struct sqlbox_parmset *res, size_t *pos)
{
	size_t i = 0;

	if (pos == NULL)
		pos = &i;
	db_electionofficial_fill(ctx, p, res, pos);
}

/*
 * Free resources from "p" and all nested objects.
 * Does not free the "p" pointer itself.
 * Has no effect if "p" is NULL.
 */
static void
db_electionofficial_unfill(struct electionofficial *p)
{
	if (p == NULL)
		return;
	free(p->username);
	free(p->hash);
}

static void
db_electionofficial_unfill_r(struct electionofficial *p)
{
	if (p == NULL)
		return;
	db_electionofficial_unfill(p);
}

void
db_electionofficial_free(struct electionofficial *p)
{
	db_electionofficial_unfill_r(p);
	free(p);
}

void
json_electionofficial_data(struct kjsonreq *r, const struct electionofficial *p)
{
	kjson_putintp(r, "id", p->id);
	kjson_putstringp(r, "username", p->username);

	/* Omitting hash: is a password hash. */

}

void
json_electionofficial_obj(struct kjsonreq *r, const struct electionofficial *p)
{
	kjson_objp_open(r, "electionofficial");
	json_electionofficial_data(r, p);
	kjson_obj_close(r);
}

int
valid_electionofficial_id(struct kpair *p)
{
	if (!kvalid_int(p))
		return 0;
	return 1;
}

int
valid_electionofficial_username(struct kpair *p)
{
	if (!kvalid_string(p))
		return 0;
	if (p->valsz <= 0)
		return 0;
	return 1;
}

int
valid_electionofficial_hash(struct kpair *p)
{
	if (!kvalid_string(p))
		return 0;
	if (p->valsz <= 6)
		return 0;
	return 1;
}

struct electionofficial *
db_electionofficial_get_credentials(struct ort *ctx, const char *v1, const char *v2)
{
	struct electionofficial *p = NULL;
	const struct sqlbox_parmset *res;
	struct sqlbox *db = ctx->db;
	struct sqlbox_parm parms[1];

	memset(parms, 0, sizeof(parms));
	parms[0].sparm = v1;
	parms[0].type = SQLBOX_PARM_STRING;

	if (!sqlbox_prepare_bind_async
	    (db, 0, STMT_ELECTIONOFFICIAL_BY_SEARCH_0, 1, parms, 0))
		exit(EXIT_FAILURE);
	if ((res = sqlbox_step(db, 0)) != NULL && res->psz) {
		p = malloc(sizeof(struct electionofficial));
		if (p == NULL) {
			perror(NULL);
			exit(EXIT_FAILURE);
		}
		db_electionofficial_fill_r(ctx, p, res, NULL);
		if (v2 == NULL || strcmp(crypt(v2, p->hash), p->hash) != 0) {
			db_electionofficial_free(p);
			p = NULL;
		}
	}
	if (res == NULL)
		exit(EXIT_FAILURE);
	if (!sqlbox_finalise(db, 0))
		exit(EXIT_FAILURE);
	return p;
}

/*
 * Fill in a voter from an open statement "stmt".
 * This starts grabbing results from "pos", which may be NULL to start 
 * from zero.
 * This follows DB_SCHEMA_VOTER's order for columns.
 */
static void
db_voter_fill(struct ort *ctx, struct voter *p, const struct sqlbox_parmset *set, size_t *pos)
{
	size_t i = 0;
	int64_t tmpint;

	if (pos == NULL)
		pos = &i;
	memset(p, 0, sizeof(*p));
	if (sqlbox_parm_int(&set->ps[(*pos)++], &p->id) == -1)
		exit(EXIT_FAILURE);
	if (sqlbox_parm_string_alloc
	    (&set->ps[(*pos)++], &p->lastname, NULL) == -1)
		exit(EXIT_FAILURE);
	if (sqlbox_parm_string_alloc
	    (&set->ps[(*pos)++], &p->givennames, NULL) == -1)
		exit(EXIT_FAILURE);
	if (sqlbox_parm_string_alloc
	    (&set->ps[(*pos)++], &p->resaddress, NULL) == -1)
		exit(EXIT_FAILURE);
	if (sqlbox_parm_string_alloc
	    (&set->ps[(*pos)++], &p->mailaddress, NULL) == -1)
		exit(EXIT_FAILURE);
	if (sqlbox_parm_string_alloc
	    (&set->ps[(*pos)++], &p->registeredparty, NULL) == -1)
		exit(EXIT_FAILURE);
	if (sqlbox_parm_int(&set->ps[(*pos)++], &tmpint) == -1)
		exit(EXIT_FAILURE);
	p->birthdate = tmpint;
	if (sqlbox_parm_blob_alloc(&set->ps[(*pos)++],
	    &p->idinfo, &p->idinfo_sz) == -1)
		exit(EXIT_FAILURE);
	if (sqlbox_parm_int(&set->ps[(*pos)++], &tmpint) == -1)
		exit(EXIT_FAILURE);
	p->status = tmpint;
	if (sqlbox_parm_int(&set->ps[(*pos)++], &tmpint) == -1)
		exit(EXIT_FAILURE);
	p->initialregtime = tmpint;
	if (sqlbox_parm_int(&set->ps[(*pos)++], &tmpint) == -1)
		exit(EXIT_FAILURE);
	p->lastupdatetime = tmpint;
	if (sqlbox_parm_int(&set->ps[(*pos)++], &p->confidential) == -1)
		exit(EXIT_FAILURE);
}

static void
db_voter_fill_r(struct ort *ctx, struct voter *p,
	const struct sqlbox_parmset *res, size_t *pos)
{
	size_t i = 0;

	if (pos == NULL)
		pos = &i;
	db_voter_fill(ctx, p, res, pos);
}

/*
 * Free resources from "p" and all nested objects.
 * Does not free the "p" pointer itself.
 * Has no effect if "p" is NULL.
 */
static void
db_voter_unfill(struct voter *p)
{
	if (p == NULL)
		return;
	free(p->lastname);
	free(p->givennames);
	free(p->resaddress);
	free(p->mailaddress);
	free(p->registeredparty);
	free(p->idinfo);
}

static void
db_voter_unfill_r(struct voter *p)
{
	if (p == NULL)
		return;
	db_voter_unfill(p);
}

void
db_voter_free(struct voter *p)
{
	db_voter_unfill_r(p);
	free(p);
}

void
db_voter_freeq(struct voter_q *q)
{
	struct voter *p;

	if (q == NULL)
		return;
	while ((p = TAILQ_FIRST(q)) != NULL) {
		TAILQ_REMOVE(q, p, _entries);
		db_voter_free(p);
	}
	free(q);
}

int64_t
db_voter_insert(struct ort *ctx, const char *v1, const char *v2, const char *v3,
     const char *v4, const char *v5, time_t v6, size_t v7_sz, const void *v7,
     enum regstatus v8, time_t v9, time_t v10, int64_t v11)
{
	int rc;
	int64_t id = -1;
	struct sqlbox *db = ctx->db;
	struct sqlbox_parm parms[11];

	memset(parms, 0, sizeof(parms));
	parms[0].sparm = v1;
	parms[0].type = SQLBOX_PARM_STRING;
	parms[1].sparm = v2;
	parms[1].type = SQLBOX_PARM_STRING;
	parms[2].sparm = v3;
	parms[2].type = SQLBOX_PARM_STRING;
	parms[3].sparm = v4;
	parms[3].type = SQLBOX_PARM_STRING;
	parms[4].sparm = v5;
	parms[4].type = SQLBOX_PARM_STRING;
	parms[5].iparm = v6;
	parms[5].type = SQLBOX_PARM_INT;
	parms[6].bparm = v7;
	parms[6].type = SQLBOX_PARM_BLOB;
	parms[6].sz = v7_sz;
	parms[7].iparm = v8;
	parms[7].type = SQLBOX_PARM_INT;
	parms[8].iparm = v9;
	parms[8].type = SQLBOX_PARM_INT;
	parms[9].iparm = v10;
	parms[9].type = SQLBOX_PARM_INT;
	parms[10].iparm = v11;
	parms[10].type = SQLBOX_PARM_INT;

	rc = sqlbox_exec(db, 0, STMT_VOTER_INSERT, 
	     11, parms, SQLBOX_STMT_CONSTRAINT);
	if (rc == SQLBOX_CODE_ERROR)
		exit(EXIT_FAILURE);
	else if (rc != SQLBOX_CODE_OK)
		return (-1);
	if (!sqlbox_lastid(db, 0, &id))
		exit(EXIT_FAILURE);
	return id;
}

void
json_voter_data(struct kjsonreq *r, const struct voter *p)
{
	char *buf1;
	size_t sz;

	/*
	 * We need to base64 encode the binary buffers prior to 
	 * serialisation.
	 * Allocate space for these buffers and do so now.
	 * We'll free the buffers at the epilogue of the function.
	 */

	sz = (p->idinfo_sz + 2) / 3 * 4 + 1;
	buf1 = malloc(sz);
	if (buf1 == NULL) {
		perror(NULL);
		exit(EXIT_FAILURE);
	}
	b64_ntop(p->idinfo, p->idinfo_sz, buf1, sz);

	kjson_putintp(r, "id", p->id);
	kjson_putstringp(r, "lastname", p->lastname);
	kjson_putstringp(r, "givennames", p->givennames);
	kjson_putstringp(r, "resaddress", p->resaddress);
	kjson_putstringp(r, "mailaddress", p->mailaddress);
	kjson_putstringp(r, "registeredparty", p->registeredparty);
	kjson_putintp(r, "birthdate", p->birthdate);
	kjson_putstringp(r, "idinfo", buf1);
	kjson_putintp(r, "status", p->status);
	kjson_putintp(r, "initialregtime", p->initialregtime);
	kjson_putintp(r, "lastupdatetime", p->lastupdatetime);
	kjson_putintp(r, "confidential", p->confidential);

	free(buf1);
}

void
json_voter_obj(struct kjsonreq *r, const struct voter *p)
{
	kjson_objp_open(r, "voter");
	json_voter_data(r, p);
	kjson_obj_close(r);
}

void
json_voter_array(struct kjsonreq *r, const struct voter_q *q)
{
	struct voter *p;

	kjson_arrayp_open(r, "voter_q");
	TAILQ_FOREACH(p, q, _entries) {
		kjson_obj_open(r);
		json_voter_data(r, p);
		kjson_obj_close(r);
	}
	kjson_array_close(r);
}

int
valid_voter_id(struct kpair *p)
{
	if (!kvalid_int(p))
		return 0;
	return 1;
}

int
valid_voter_lastname(struct kpair *p)
{
	if (!kvalid_string(p))
		return 0;
	if (p->valsz <= 0)
		return 0;
	return 1;
}

int
valid_voter_givennames(struct kpair *p)
{
	if (!kvalid_string(p))
		return 0;
	if (p->valsz <= 0)
		return 0;
	return 1;
}

int
valid_voter_resaddress(struct kpair *p)
{
	if (!kvalid_string(p))
		return 0;
	if (p->valsz <= 0)
		return 0;
	return 1;
}

int
valid_voter_mailaddress(struct kpair *p)
{
	if (!kvalid_string(p))
		return 0;
	if (p->valsz <= 0)
		return 0;
	return 1;
}

int
valid_voter_registeredparty(struct kpair *p)
{
	if (!kvalid_string(p))
		return 0;
	if (p->valsz <= 0)
		return 0;
	return 1;
}

int
valid_voter_birthdate(struct kpair *p)
{
	if (!kvalid_date(p))
		return 0;
	if (p->parsed.i <= 0)
		return 0;
	return 1;
}

int
valid_voter_idinfo(struct kpair *p)
{
	if (p->valsz <= 0)
		return 0;
	return 1;
}

int
valid_voter_status(struct kpair *p)
{
	if (!kvalid_int(p))
		return 0;
	switch(p->parsed.i) {
	case 0:
	case 1:
	case 2:
		break;
	default:
		return 0;
	}
	return 1;
}

int
valid_voter_initialregtime(struct kpair *p)
{
	if (!kvalid_date(p))
		return 0;
	if (p->parsed.i <= 0)
		return 0;
	return 1;
}

int
valid_voter_lastupdatetime(struct kpair *p)
{
	if (!kvalid_date(p))
		return 0;
	if (p->parsed.i <= 0)
		return 0;
	return 1;
}

int
valid_voter_confidential(struct kpair *p)
{
	if (!kvalid_bit(p))
		return 0;
	return 1;
}

struct voter_q *
db_voter_list_registration(struct ort *ctx, const char *v1, const char *v2,
     time_t v3, int64_t v4)
{
	struct voter *p;
	struct voter_q *q;
	const struct sqlbox_parmset *res;
	struct sqlbox *db = ctx->db;
	struct sqlbox_parm parms[4];

	memset(parms, 0, sizeof(parms));
	q = malloc(sizeof(struct voter_q));
	if (q == NULL) {
		perror(NULL);
		exit(EXIT_FAILURE);
	}
	TAILQ_INIT(q);

	parms[0].sparm = v1;
	parms[0].type = SQLBOX_PARM_STRING;
	parms[1].sparm = v2;
	parms[1].type = SQLBOX_PARM_STRING;
	parms[2].iparm = v3;
	parms[2].type = SQLBOX_PARM_INT;
	parms[3].iparm = v4;
	parms[3].type = SQLBOX_PARM_INT;

	if (!sqlbox_prepare_bind_async
	    (db, 0, STMT_VOTER_BY_SEARCH_0,
	     4, parms, SQLBOX_STMT_MULTI))
		exit(EXIT_FAILURE);
	while ((res = sqlbox_step(db, 0)) != NULL && res->psz) {
		p = malloc(sizeof(struct voter));
		if (p == NULL) {
			perror(NULL);
			exit(EXIT_FAILURE);
		}
		db_voter_fill_r(ctx, p, res, NULL);
		TAILQ_INSERT_TAIL(q, p, _entries);
	}
	if (res == NULL)
		exit(EXIT_FAILURE);
	if (!sqlbox_finalise(db, 0))
		exit(EXIT_FAILURE);
	return q;
}

struct voter *
db_voter_get_registrationforupdate(struct ort *ctx, const char *v1, const char *v2,
     const char *v3, const char *v4, time_t v5, size_t v6_sz, const void *v6,
     int64_t v7)
{
	struct voter *p = NULL;
	const struct sqlbox_parmset *res;
	struct sqlbox *db = ctx->db;
	struct sqlbox_parm parms[7];

	memset(parms, 0, sizeof(parms));
	parms[0].sparm = v1;
	parms[0].type = SQLBOX_PARM_STRING;
	parms[1].sparm = v2;
	parms[1].type = SQLBOX_PARM_STRING;
	parms[2].sparm = v3;
	parms[2].type = SQLBOX_PARM_STRING;
	parms[3].sparm = v4;
	parms[3].type = SQLBOX_PARM_STRING;
	parms[4].iparm = v5;
	parms[4].type = SQLBOX_PARM_INT;
	parms[5].bparm = v6;
	parms[5].type = SQLBOX_PARM_BLOB;
	parms[5].sz = v6_sz;
	parms[6].iparm = v7;
	parms[6].type = SQLBOX_PARM_INT;

	if (!sqlbox_prepare_bind_async
	    (db, 0, STMT_VOTER_BY_SEARCH_1, 7, parms, 0))
		exit(EXIT_FAILURE);
	if ((res = sqlbox_step(db, 0)) != NULL && res->psz) {
		p = malloc(sizeof(struct voter));
		if (p == NULL) {
			perror(NULL);
			exit(EXIT_FAILURE);
		}
		db_voter_fill_r(ctx, p, res, NULL);
	}
	if (res == NULL)
		exit(EXIT_FAILURE);
	if (!sqlbox_finalise(db, 0))
		exit(EXIT_FAILURE);
	return p;
}

struct voter_q *
db_voter_list_officialsearch(struct ort *ctx, const char *v1, const char *v2,
     const char *v3, const char *v4, time_t v5, time_t v6)
{
	struct voter *p;
	struct voter_q *q;
	const struct sqlbox_parmset *res;
	struct sqlbox *db = ctx->db;
	struct sqlbox_parm parms[6];

	memset(parms, 0, sizeof(parms));
	q = malloc(sizeof(struct voter_q));
	if (q == NULL) {
		perror(NULL);
		exit(EXIT_FAILURE);
	}
	TAILQ_INIT(q);

	parms[0].sparm = v1;
	parms[0].type = SQLBOX_PARM_STRING;
	parms[1].sparm = v2;
	parms[1].type = SQLBOX_PARM_STRING;
	parms[2].sparm = v3;
	parms[2].type = SQLBOX_PARM_STRING;
	parms[3].sparm = v4;
	parms[3].type = SQLBOX_PARM_STRING;
	parms[4].iparm = v5;
	parms[4].type = SQLBOX_PARM_INT;
	parms[5].iparm = v6;
	parms[5].type = SQLBOX_PARM_INT;

	if (!sqlbox_prepare_bind_async
	    (db, 0, STMT_VOTER_BY_SEARCH_2,
	     6, parms, SQLBOX_STMT_MULTI))
		exit(EXIT_FAILURE);
	while ((res = sqlbox_step(db, 0)) != NULL && res->psz) {
		p = malloc(sizeof(struct voter));
		if (p == NULL) {
			perror(NULL);
			exit(EXIT_FAILURE);
		}
		db_voter_fill_r(ctx, p, res, NULL);
		TAILQ_INSERT_TAIL(q, p, _entries);
	}
	if (res == NULL)
		exit(EXIT_FAILURE);
	if (!sqlbox_finalise(db, 0))
		exit(EXIT_FAILURE);
	return q;
}

int
db_voter_update_info(struct ort *ctx, const char *v1, const char *v2, const char *v3,
     const char *v4, const char *v5, time_t v6, size_t v7_sz, const void *v7,
     enum regstatus v8, time_t v9, int64_t v10, int64_t v11)
{
	enum sqlbox_code c;
	struct sqlbox *db = ctx->db;
	struct sqlbox_parm parms[11];

	memset(parms, 0, sizeof(parms));
	parms[0].sparm = v1;
	parms[0].type = SQLBOX_PARM_STRING;
	parms[1].sparm = v2;
	parms[1].type = SQLBOX_PARM_STRING;
	parms[2].sparm = v3;
	parms[2].type = SQLBOX_PARM_STRING;
	parms[3].sparm = v4;
	parms[3].type = SQLBOX_PARM_STRING;
	parms[4].sparm = v5;
	parms[4].type = SQLBOX_PARM_STRING;
	parms[5].iparm = v6;
	parms[5].type = SQLBOX_PARM_INT;
	parms[6].bparm = v7;
	parms[6].type = SQLBOX_PARM_BLOB;
	parms[6].sz = v7_sz;
	parms[7].iparm = v8;
	parms[7].type = SQLBOX_PARM_INT;
	parms[8].iparm = v9;
	parms[8].type = SQLBOX_PARM_INT;
	parms[9].iparm = v10;
	parms[9].type = SQLBOX_PARM_INT;
	parms[10].iparm = v11;
	parms[10].type = SQLBOX_PARM_INT;

	c = sqlbox_exec
		(db, 0, STMT_VOTER_UPDATE_0,
		 11, parms, SQLBOX_STMT_CONSTRAINT);
	if (c == SQLBOX_CODE_ERROR)
		exit(EXIT_FAILURE);
	return (c == SQLBOX_CODE_OK) ? 1 : 0;
}

int
db_voter_update_status(struct ort *ctx, enum regstatus v1, time_t v2, int64_t v3)
{
	enum sqlbox_code c;
	struct sqlbox *db = ctx->db;
	struct sqlbox_parm parms[3];

	memset(parms, 0, sizeof(parms));
	parms[0].iparm = v1;
	parms[0].type = SQLBOX_PARM_INT;
	parms[1].iparm = v2;
	parms[1].type = SQLBOX_PARM_INT;
	parms[2].iparm = v3;
	parms[2].type = SQLBOX_PARM_INT;

	c = sqlbox_exec
		(db, 0, STMT_VOTER_UPDATE_1,
		 3, parms, SQLBOX_STMT_CONSTRAINT);
	if (c == SQLBOX_CODE_ERROR)
		exit(EXIT_FAILURE);
	return (c == SQLBOX_CODE_OK) ? 1 : 0;
}

/*
 * Fill in a electionofficialsession from an open statement "stmt".
 * This starts grabbing results from "pos", which may be NULL to start 
 * from zero.
 * This follows DB_SCHEMA_ELECTIONOFFICIALSESSION's order for columns.
 */
static void
db_electionofficialsession_fill(struct ort *ctx, struct electionofficialsession *p, const struct sqlbox_parmset *set, size_t *pos)
{
	size_t i = 0;
	int64_t tmpint;

	if (pos == NULL)
		pos = &i;
	memset(p, 0, sizeof(*p));
	if (sqlbox_parm_int(&set->ps[(*pos)++], &p->id) == -1)
		exit(EXIT_FAILURE);
	if (sqlbox_parm_int(&set->ps[(*pos)++], &p->officialid) == -1)
		exit(EXIT_FAILURE);
	if (sqlbox_parm_int(&set->ps[(*pos)++], &p->token) == -1)
		exit(EXIT_FAILURE);
	if (sqlbox_parm_int(&set->ps[(*pos)++], &tmpint) == -1)
		exit(EXIT_FAILURE);
	p->ctime = tmpint;
}

static void
db_electionofficialsession_fill_r(struct ort *ctx, struct electionofficialsession *p,
	const struct sqlbox_parmset *res, size_t *pos)
{
	size_t i = 0;

	if (pos == NULL)
		pos = &i;
	db_electionofficialsession_fill(ctx, p, res, pos);
	db_electionofficial_fill_r(ctx, &p->electionofficial, res, pos);
}

/*
 * Free resources from "p" and all nested objects.
 * Does not free the "p" pointer itself.
 * Has no effect if "p" is NULL.
 */
static void
db_electionofficialsession_unfill(struct electionofficialsession *p)
{
	if (p == NULL)
		return;
}

static void
db_electionofficialsession_unfill_r(struct electionofficialsession *p)
{
	if (p == NULL)
		return;
	db_electionofficialsession_unfill(p);
	db_electionofficial_unfill_r(&p->electionofficial);
}

void
db_electionofficialsession_free(struct electionofficialsession *p)
{
	db_electionofficialsession_unfill_r(p);
	free(p);
}

void
db_electionofficialsession_freeq(struct electionofficialsession_q *q)
{
	struct electionofficialsession *p;

	if (q == NULL)
		return;
	while ((p = TAILQ_FIRST(q)) != NULL) {
		TAILQ_REMOVE(q, p, _entries);
		db_electionofficialsession_free(p);
	}
	free(q);
}

int64_t
db_electionofficialsession_insert(struct ort *ctx, int64_t v1, int64_t v2,
     time_t v3)
{
	int rc;
	int64_t id = -1;
	struct sqlbox *db = ctx->db;
	struct sqlbox_parm parms[3];

	memset(parms, 0, sizeof(parms));
	parms[0].iparm = v1;
	parms[0].type = SQLBOX_PARM_INT;
	parms[1].iparm = v2;
	parms[1].type = SQLBOX_PARM_INT;
	parms[2].iparm = v3;
	parms[2].type = SQLBOX_PARM_INT;

	rc = sqlbox_exec(db, 0, STMT_ELECTIONOFFICIALSESSION_INSERT, 
	     3, parms, SQLBOX_STMT_CONSTRAINT);
	if (rc == SQLBOX_CODE_ERROR)
		exit(EXIT_FAILURE);
	else if (rc != SQLBOX_CODE_OK)
		return (-1);
	if (!sqlbox_lastid(db, 0, &id))
		exit(EXIT_FAILURE);
	return id;
}

void
json_electionofficialsession_data(struct kjsonreq *r, const struct electionofficialsession *p)
{
	kjson_putintp(r, "id", p->id);
	kjson_objp_open(r, "electionofficial");
	json_electionofficial_data(r, &p->electionofficial);
	kjson_obj_close(r);
	kjson_putintp(r, "officialid", p->officialid);
	kjson_putintp(r, "token", p->token);
	kjson_putintp(r, "ctime", p->ctime);
}

void
json_electionofficialsession_obj(struct kjsonreq *r, const struct electionofficialsession *p)
{
	kjson_objp_open(r, "electionofficialsession");
	json_electionofficialsession_data(r, p);
	kjson_obj_close(r);
}

void
json_electionofficialsession_array(struct kjsonreq *r, const struct electionofficialsession_q *q)
{
	struct electionofficialsession *p;

	kjson_arrayp_open(r, "electionofficialsession_q");
	TAILQ_FOREACH(p, q, _entries) {
		kjson_obj_open(r);
		json_electionofficialsession_data(r, p);
		kjson_obj_close(r);
	}
	kjson_array_close(r);
}

int
valid_electionofficialsession_id(struct kpair *p)
{
	if (!kvalid_int(p))
		return 0;
	return 1;
}

int
valid_electionofficialsession_officialid(struct kpair *p)
{
	if (!kvalid_int(p))
		return 0;
	return 1;
}

int
valid_electionofficialsession_token(struct kpair *p)
{
	if (!kvalid_int(p))
		return 0;
	return 1;
}

int
valid_electionofficialsession_ctime(struct kpair *p)
{
	if (!kvalid_int(p))
		return 0;
	return 1;
}

struct electionofficialsession *
db_electionofficialsession_get_officialcreds(struct ort *ctx, int64_t v1,
     int64_t v2)
{
	struct electionofficialsession *p = NULL;
	const struct sqlbox_parmset *res;
	struct sqlbox *db = ctx->db;
	struct sqlbox_parm parms[2];

	memset(parms, 0, sizeof(parms));
	parms[0].iparm = v1;
	parms[0].type = SQLBOX_PARM_INT;
	parms[1].iparm = v2;
	parms[1].type = SQLBOX_PARM_INT;

	if (!sqlbox_prepare_bind_async
	    (db, 0, STMT_ELECTIONOFFICIALSESSION_BY_SEARCH_0, 2, parms, 0))
		exit(EXIT_FAILURE);
	if ((res = sqlbox_step(db, 0)) != NULL && res->psz) {
		p = malloc(sizeof(struct electionofficialsession));
		if (p == NULL) {
			perror(NULL);
			exit(EXIT_FAILURE);
		}
		db_electionofficialsession_fill_r(ctx, p, res, NULL);
	}
	if (res == NULL)
		exit(EXIT_FAILURE);
	if (!sqlbox_finalise(db, 0))
		exit(EXIT_FAILURE);
	return p;
}

struct electionofficialsession_q *
db_electionofficialsession_list_byctime(struct ort *ctx, time_t v1)
{
	struct electionofficialsession *p;
	struct electionofficialsession_q *q;
	const struct sqlbox_parmset *res;
	struct sqlbox *db = ctx->db;
	struct sqlbox_parm parms[1];

	memset(parms, 0, sizeof(parms));
	q = malloc(sizeof(struct electionofficialsession_q));
	if (q == NULL) {
		perror(NULL);
		exit(EXIT_FAILURE);
	}
	TAILQ_INIT(q);

	parms[0].iparm = v1;
	parms[0].type = SQLBOX_PARM_INT;

	if (!sqlbox_prepare_bind_async
	    (db, 0, STMT_ELECTIONOFFICIALSESSION_BY_SEARCH_1,
	     1, parms, SQLBOX_STMT_MULTI))
		exit(EXIT_FAILURE);
	while ((res = sqlbox_step(db, 0)) != NULL && res->psz) {
		p = malloc(sizeof(struct electionofficialsession));
		if (p == NULL) {
			perror(NULL);
			exit(EXIT_FAILURE);
		}
		db_electionofficialsession_fill_r(ctx, p, res, NULL);
		TAILQ_INSERT_TAIL(q, p, _entries);
	}
	if (res == NULL)
		exit(EXIT_FAILURE);
	if (!sqlbox_finalise(db, 0))
		exit(EXIT_FAILURE);
	return q;
}

int
db_electionofficialsession_delete_officialsession(struct ort *ctx, int64_t v1,
     int64_t v2)
{
	enum sqlbox_code c;
	struct sqlbox *db = ctx->db;
	struct sqlbox_parm parms[2];

	memset(parms, 0, sizeof(parms));
	parms[0].iparm = v1;
	parms[0].type = SQLBOX_PARM_INT;
	parms[1].iparm = v2;
	parms[1].type = SQLBOX_PARM_INT;

	c = sqlbox_exec
		(db, 0, STMT_ELECTIONOFFICIALSESSION_DELETE_0,
		 2, parms, SQLBOX_STMT_CONSTRAINT);
	if (c == SQLBOX_CODE_ERROR)
		exit(EXIT_FAILURE);
	return (c == SQLBOX_CODE_OK) ? 1 : 0;
}

/*
 * Fill in a voterupdatesession from an open statement "stmt".
 * This starts grabbing results from "pos", which may be NULL to start 
 * from zero.
 * This follows DB_SCHEMA_VOTERUPDATESESSION's order for columns.
 */
static void
db_voterupdatesession_fill(struct ort *ctx, struct voterupdatesession *p, const struct sqlbox_parmset *set, size_t *pos)
{
	size_t i = 0;
	int64_t tmpint;

	if (pos == NULL)
		pos = &i;
	memset(p, 0, sizeof(*p));
	if (sqlbox_parm_int(&set->ps[(*pos)++], &p->id) == -1)
		exit(EXIT_FAILURE);
	if (sqlbox_parm_int(&set->ps[(*pos)++], &p->voterid) == -1)
		exit(EXIT_FAILURE);
	if (sqlbox_parm_int(&set->ps[(*pos)++], &p->token) == -1)
		exit(EXIT_FAILURE);
	if (sqlbox_parm_int(&set->ps[(*pos)++], &tmpint) == -1)
		exit(EXIT_FAILURE);
	p->ctime = tmpint;
}

static void
db_voterupdatesession_fill_r(struct ort *ctx, struct voterupdatesession *p,
	const struct sqlbox_parmset *res, size_t *pos)
{
	size_t i = 0;

	if (pos == NULL)
		pos = &i;
	db_voterupdatesession_fill(ctx, p, res, pos);
	db_voter_fill_r(ctx, &p->voter, res, pos);
}

/*
 * Free resources from "p" and all nested objects.
 * Does not free the "p" pointer itself.
 * Has no effect if "p" is NULL.
 */
static void
db_voterupdatesession_unfill(struct voterupdatesession *p)
{
	if (p == NULL)
		return;
}

static void
db_voterupdatesession_unfill_r(struct voterupdatesession *p)
{
	if (p == NULL)
		return;
	db_voterupdatesession_unfill(p);
	db_voter_unfill_r(&p->voter);
}

void
db_voterupdatesession_free(struct voterupdatesession *p)
{
	db_voterupdatesession_unfill_r(p);
	free(p);
}

void
db_voterupdatesession_freeq(struct voterupdatesession_q *q)
{
	struct voterupdatesession *p;

	if (q == NULL)
		return;
	while ((p = TAILQ_FIRST(q)) != NULL) {
		TAILQ_REMOVE(q, p, _entries);
		db_voterupdatesession_free(p);
	}
	free(q);
}

int64_t
db_voterupdatesession_insert(struct ort *ctx, int64_t v1, int64_t v2, time_t v3)
{
	int rc;
	int64_t id = -1;
	struct sqlbox *db = ctx->db;
	struct sqlbox_parm parms[3];

	memset(parms, 0, sizeof(parms));
	parms[0].iparm = v1;
	parms[0].type = SQLBOX_PARM_INT;
	parms[1].iparm = v2;
	parms[1].type = SQLBOX_PARM_INT;
	parms[2].iparm = v3;
	parms[2].type = SQLBOX_PARM_INT;

	rc = sqlbox_exec(db, 0, STMT_VOTERUPDATESESSION_INSERT, 
	     3, parms, SQLBOX_STMT_CONSTRAINT);
	if (rc == SQLBOX_CODE_ERROR)
		exit(EXIT_FAILURE);
	else if (rc != SQLBOX_CODE_OK)
		return (-1);
	if (!sqlbox_lastid(db, 0, &id))
		exit(EXIT_FAILURE);
	return id;
}

void
json_voterupdatesession_data(struct kjsonreq *r, const struct voterupdatesession *p)
{
	kjson_putintp(r, "id", p->id);
	kjson_objp_open(r, "voter");
	json_voter_data(r, &p->voter);
	kjson_obj_close(r);
	kjson_putintp(r, "voterid", p->voterid);
	kjson_putintp(r, "token", p->token);
	kjson_putintp(r, "ctime", p->ctime);
}

void
json_voterupdatesession_obj(struct kjsonreq *r, const struct voterupdatesession *p)
{
	kjson_objp_open(r, "voterupdatesession");
	json_voterupdatesession_data(r, p);
	kjson_obj_close(r);
}

void
json_voterupdatesession_array(struct kjsonreq *r, const struct voterupdatesession_q *q)
{
	struct voterupdatesession *p;

	kjson_arrayp_open(r, "voterupdatesession_q");
	TAILQ_FOREACH(p, q, _entries) {
		kjson_obj_open(r);
		json_voterupdatesession_data(r, p);
		kjson_obj_close(r);
	}
	kjson_array_close(r);
}

int
valid_voterupdatesession_id(struct kpair *p)
{
	if (!kvalid_int(p))
		return 0;
	return 1;
}

int
valid_voterupdatesession_voterid(struct kpair *p)
{
	if (!kvalid_int(p))
		return 0;
	return 1;
}

int
valid_voterupdatesession_token(struct kpair *p)
{
	if (!kvalid_int(p))
		return 0;
	return 1;
}

int
valid_voterupdatesession_ctime(struct kpair *p)
{
	if (!kvalid_int(p))
		return 0;
	return 1;
}

struct voterupdatesession *
db_voterupdatesession_get_updatecreds(struct ort *ctx, int64_t v1, int64_t v2)
{
	struct voterupdatesession *p = NULL;
	const struct sqlbox_parmset *res;
	struct sqlbox *db = ctx->db;
	struct sqlbox_parm parms[2];

	memset(parms, 0, sizeof(parms));
	parms[0].iparm = v1;
	parms[0].type = SQLBOX_PARM_INT;
	parms[1].iparm = v2;
	parms[1].type = SQLBOX_PARM_INT;

	if (!sqlbox_prepare_bind_async
	    (db, 0, STMT_VOTERUPDATESESSION_BY_SEARCH_0, 2, parms, 0))
		exit(EXIT_FAILURE);
	if ((res = sqlbox_step(db, 0)) != NULL && res->psz) {
		p = malloc(sizeof(struct voterupdatesession));
		if (p == NULL) {
			perror(NULL);
			exit(EXIT_FAILURE);
		}
		db_voterupdatesession_fill_r(ctx, p, res, NULL);
	}
	if (res == NULL)
		exit(EXIT_FAILURE);
	if (!sqlbox_finalise(db, 0))
		exit(EXIT_FAILURE);
	return p;
}

struct voterupdatesession_q *
db_voterupdatesession_list_byctime(struct ort *ctx, time_t v1)
{
	struct voterupdatesession *p;
	struct voterupdatesession_q *q;
	const struct sqlbox_parmset *res;
	struct sqlbox *db = ctx->db;
	struct sqlbox_parm parms[1];

	memset(parms, 0, sizeof(parms));
	q = malloc(sizeof(struct voterupdatesession_q));
	if (q == NULL) {
		perror(NULL);
		exit(EXIT_FAILURE);
	}
	TAILQ_INIT(q);

	parms[0].iparm = v1;
	parms[0].type = SQLBOX_PARM_INT;

	if (!sqlbox_prepare_bind_async
	    (db, 0, STMT_VOTERUPDATESESSION_BY_SEARCH_1,
	     1, parms, SQLBOX_STMT_MULTI))
		exit(EXIT_FAILURE);
	while ((res = sqlbox_step(db, 0)) != NULL && res->psz) {
		p = malloc(sizeof(struct voterupdatesession));
		if (p == NULL) {
			perror(NULL);
			exit(EXIT_FAILURE);
		}
		db_voterupdatesession_fill_r(ctx, p, res, NULL);
		TAILQ_INSERT_TAIL(q, p, _entries);
	}
	if (res == NULL)
		exit(EXIT_FAILURE);
	if (!sqlbox_finalise(db, 0))
		exit(EXIT_FAILURE);
	return q;
}

int
db_voterupdatesession_delete_votersession(struct ort *ctx, int64_t v1, int64_t v2)
{
	enum sqlbox_code c;
	struct sqlbox *db = ctx->db;
	struct sqlbox_parm parms[2];

	memset(parms, 0, sizeof(parms));
	parms[0].iparm = v1;
	parms[0].type = SQLBOX_PARM_INT;
	parms[1].iparm = v2;
	parms[1].type = SQLBOX_PARM_INT;

	c = sqlbox_exec
		(db, 0, STMT_VOTERUPDATESESSION_DELETE_0,
		 2, parms, SQLBOX_STMT_CONSTRAINT);
	if (c == SQLBOX_CODE_ERROR)
		exit(EXIT_FAILURE);
	return (c == SQLBOX_CODE_OK) ? 1 : 0;
}

